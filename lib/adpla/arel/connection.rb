module Adpla
  module Arel
    class Connection
      def initialize(klass)
        @table = klass.table
        @method = klass.name.downcase.pluralize.to_sym
        @api = @table.engine.api
      end

      def primary_key(table_name)
        'id'
      end

      def to_sql(*args)
        to_nosql(*args)
      end

      # the object generated by this method will be passed to the self#execute
      def to_nosql(select_manager, bind_values)
        qb = Adpla::Arel::QueryBuilder.new(@table)
        if ::Arel::Nodes::Intersect === select_manager
          filter_context = select_manager.right
          select_manager = select_manager.left
          constraints(filter_context).each {|c| qb.where(c)}
          projections(filter_context).each {|c| qb.add_facet(c)}
        end
        constraints(select_manager).each {|c| qb.where(c)}
        orders(select_manager).each {|c| qb.order(c)}
        projections(select_manager).each {|c| qb.select(c)}
        if (limit = limit(select_manager))
          qb.take(limit)
        end
        if (offset = offset(select_manager))
          qb.skip(offset)
        end
        qb.query_opts
      end

      def limit(arel_node)
        case arel_node
        when ::Arel::SelectManager
          arel_node.limit
        when ::Arel::Nodes::SelectStatement
          arel_node.limit && arel_node.limit.expr
        else
          nil
        end
      end

      def offset(arel_node)
        case arel_node
        when ::Arel::SelectManager
          arel_node.offset
        when ::Arel::Nodes::SelectStatement
          arel_node.offset && arel_node.offset.expr
        else
          nil
        end
      end

      def constraints(arel_node)
        case arel_node
        when ::Arel::SelectManager
          arel_node.constraints
        when ::Arel::Nodes::SelectStatement
          arel_node.cores.last.wheres
        else
          nil
        end
      end

      def projections(arel_node)
        case arel_node
        when ::Arel::SelectManager
          arel_node.projections
        when ::Arel::Nodes::SelectStatement
          arel_node.cores.last.projections
        else
          nil
        end
      end        

      def orders(arel_node)
        case arel_node
        when ::Arel::SelectManager
          arel_node.orders
        when ::Arel::Nodes::SelectStatement
          arel_node.orders
        else
          nil
        end
      end        

      def to_aliases(select_manager, bind_values)
        qb = Adpla::Arel::QueryBuilder.new(@table)
        if ::Arel::Nodes::Intersect === select_manager
          select_manager = select_manager.left
        end
        projections(select_manager).each {|c| qb.select(c)}
        qb.aliases
      end

      def execute(query, aliases = {})
        json = @api.send(@method, query)
        json = json.length > 0 ? JSON.load(json) : {}
        if json['docs'] and aliases
          json['docs'].each do |doc|
            aliases.each do |k,v|
              if doc[k]
                old = doc.delete(k)
                if old and doc[v]
                  doc[v] = Array(doc[v]) if doc[v]
                  Array(old).each {|ov| doc[v] << ov}
                else
                  doc[v] = old
                end
              end
            end
          end
        end
        json
      end

      def schema_cache
        ActiveRecord::ConnectionAdapters::SchemaCache.new(self)
      end

      def table_exists?(table_name)
        ['Collection', 'Item'].include? table_name
      end

      # this is called by the BigTable impl
      def columns(table_name, *rest)
        @table.fields.map {|s| ::ActiveRecord::ConnectionAdapters::Column.new(s.to_s, nil, nil)}
      end

      # Sanitization methods that are expected to be provided by a connection impl
      def sanitize_limit(limit_value)
        if (0..500) === limit_value.to_s.to_i
          limit_value
        else
          ActiveNoSql::Relation::DEFAULT_PAGE_SIZE
        end
      end

      def sanitize_filter_name(filter_value)
        if filter_value.is_a? Array
          return filter_value.collect {|x| sanitize_filter_name(x)}.compact
        else
          if @table.facets.include? filter_value.to_sym
            return filter_value
          else
            raise "#{filter_value} is not a facetable field"
            #Rails.logger.warn "Ignoring #{filter_value} (not a filterable field)" if Rails.logger
            #return nil
          end
        end
      end
    end
  end
 
end